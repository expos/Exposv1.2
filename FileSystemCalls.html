<!--Latex References Fixed -->


<html>
<head>
<title>File System Calls</title>
<link rel="stylesheet" type="text/css" href="./main.css"/>
</head>
<body>

<h1>File System Calls</h1>



<div id="nav">
<div id="nav1">
<ul>
<li><a href="index.html">Home</a>
<li><a href="MachineSpecIntro.html">Machine Specification(Intro)</a>
<li><a href="Registers.html">Registers</a>
<li><a href="Memory.html">Memory</a>
<li><a href="Process.html">Process</a>
<li><a href="Instructions.html">Instructions</a>
<li><a href="Interrupt.html">Interrupt</a>
<li><a href="FileSystem.html">File System</a>
<li><a href="OSIntroduction.html">OS Introduction</a>
<li><a href="OSStartupCode.html">OS Startup Code</a>
<li><a href="Halt.html">Halt</a>
<li><a href="FileSystemCalls.html">File System Call</a>
<li><a href="Multiprogramming.html">Multi-Programming</a>
<li><a href="ProcessSystemCall.html">Process System Call</a>
<li><a href="Conclusion.html">Conclusion</a>
<li><a href="SPSIL.html">SPSIL</a>
<li><a href="APSIL.html">APSIL</a>
<li><a href="Bibliography.html">Bibliography</a>
</ul>
</div>


<div id="nav2">
<p class="nav2">
Download as pdf
</p>
<ul>
<li><a href="">Machine Spec</a>
<li><a href="">APSIL</a>
<li><a href="">SPSIL</a>
</ul>
</div>
</div>

<div id="main">

<h2>Scratchpad</h2>
<p>
There is a specific page of the memory which is reserved to store temporary data. This page is known as the <i>Scratchpad</i>. The scratchpad is required since any block of the disk cannot be accessed directly  by a process. It has to be present in the memory for access. Hence, any disk block that has to be read or written into is first brought into the scratchpad. It is then read or modified and written back into the disk (if required).
</p>
<p>
The page 1 of the memory is used as the scratchpad. Once the OS has booted up there is no need for the OS startup code. So this page can be reused as the scratchpad.
</p>

<h2>Global File Table and Local File Table</h2>
<p>
Before explaining the system calls, we introduce two data structures : <i>Global File Table</i> and <i>Local File Table</i>.
</p>
<ul>
<a name = "GFT">
	<li> <b>Global File Table</b>
	 It is a table consisting of a list of all the open files in the system. Since each of the 12 processes can open 4 files at a time, this table consists of a maximum of 48 entries. Each entry of the global file table has the following structure as shown in figure.</li>
	<div id="imageCaption">
	<img src="./images/gft_struct.png" alt="GFT Structure"><br/>
	Structure of a GFT entry</div>
	 
	 <ul>
		 <li> <b>FAT index entry :</b> It is used to index the memory copy of the file allocation table to get information about that particular file.

		 <li> <b>lseek :</b> It is used to get the current position of the next character that will be read from the file. By default, when a file is opened, this parameter has a value 0.
	 </ul>

	<li> <b>Local File table</b>
	In addition to the fields discussed earlier, the PCB has an additional field known as the <em>Local File Table</em>. The local file table consists of 4 entries each of size one word. Each entry corresponds to a file opened by that particular process and stores the global file table index of that file. Thus a process can open a maximum of 4 files. 
	<p>
	The local file table is indexed by a <i>file descriptor</i>(an integer value ranging from 0 to 3).
	</p>
</ul>

<h2>Modifications in the OS Startup Code</h2>
<ul>
	<li> The Global File Table in the memory must be initialised with NULL values.

	<li> The Local File Table entries in the PCB of the INIT process must be initialised with NULL values.
</ul>

<h2>File System Calls</h2>
<p>
<i>File system calls</i> are used by a process when it has to create, delete or manipulate <i>Data files</i> that reside on the disk(file system). There are seven file system calls. An interrupt is associated with each system call. All the necessary arguments for a system call are available in the user stack with the system call number as the last argument.
</p>
<p>
Interrupt specifications for different <i>File system calls</i> are as follows:
</p>
<h3>INT 1</h3>
<p>
The file system calls <i>Create</i> and <i>Delete</i> invoke INT 1. INT 1 handles these system calls as follows.
</p>
<ol>
	<li>  <b>Create :</b> This system call is used to create a new file in the file system whose name is specified in the argument.
	<div>Syntax : <tt>int Create(fileName)</tt></div>
	<div>Syscall no : 1</div>
	<ul>
		<li> First of all, the memory copy of the FAT is searched for a free entry. If no free entry is found, an appropriate error code is returned.
		
		<li> Next, the memory copy of the disk free list is searched to find a free block number.If no free block is found, an appropriate error code is returned. This block is used as the basic block of the file to be created.
		
		<li> The <tt>fileName</tt> specified in the argument and the free block number obtained in the previous step are stored in the <em>file name</em> field and <em>basic block number</em> field of the free FAT entry, respectively.
				
		<li> The <em>file size</em> field of the FAT entry is initialized to zero.
		
		<li> Each entry of the block list in the basic block is initialized to zero.
		
		<li> The updated copies of FAT and disk free list in the memory are committed to the disk.
		
		<li> The return value of this system call is 0 in case of success and the appropriate error code in case of failure.
	</ul>

	<li> <b>Delete :</b> This system call is used to delete the file from the file system whose name is specified in the argument. 
	<div>Syntax : <tt>int Delete(fileName)</tt></div> 
	<div>Syscall no : 2</div>
	<ul>
		<li> The memory copy of the FAT is searched using the <tt>fileName</tt> to get the corresponding FAT entry. If no entry is found, an appropriate error code is returned.
		
		<li> If the file is already open an appropriate error code is returned. We adopt the following steps to check if the file is open.
		<ul>
			<li> The <em>FAT index entry</em> of each global file table entry is used to fetch the filename of the corresponding open file from the memory copy of the FAT.
			
			<li> Each of the filenames obtained in the previous step is compared with the <tt>fileName</tt>. If match is found, we conclude that the file is currently in open.
		</ul>
		<li> The <em>basic block number</em> field in this FAT entry obtained, is then used to load the basic block of the file into the scratchpad.
		
		<li> Each entry in the block list of the basic block is used to find the data blocks of the file. Then, entries in the memory copy of the disk free list corresponding to these data blocks are set to zero, thereby freeing them.
		
		<li> Finally, the FAT entry of the file is removed.
		
		<li> The updated copies of FAT and disk free list in the memory are committed to the disk.
		
		<li> The return value of this system call is 0 in case of success and the appropriate error code in case of failure.
	</ul>
</ol>

<h3>INT 2</h3>
<p>
The file system calls <i>Open</i> and <i>Close</i> invoke INT 2. INT 2 handles these system calls as follows.
</p>
<ol>
	<li> <b>Open :</b> This system call is used to open an existing file whose name is specified in the argument.
	<div>Syntax : <tt>int Open(fileName)</tt></div> 
	<div>Syscall no : 3</div>
	<ul>
		<li>  First of all, a free entry is searched in the local file table of the process. If there are no free entries, in the case where a process already has 4 open files, an appropriate error code is returned.
		
		<li> Then, the global file table is searched for a free entry. If there is no free entry, an appropriate error code is returned else a new global file table entry is created and the fields are filled with appropriate values in the following manner:
		<ul>
			<li> The memory copy of FAT is searched using the <tt>fileName</tt> and the corresponding index of that file in the FAT is stored as the <em>FAT index</em>. If the file does not have an entry in the FAT, an appropriate error code is returned.
			
			<li> The <em>lseek</em> field is set to zero.
		</ul>
		
		<li> The index of this global file table entry is stored in its local file table.
		
		<li> The index of this entry in the local file table is returned as a return value of the system call. This is known as the file descriptor.
	</ul>

	<li>  <b>Close :</b> This system call is used to close an open file. The file can only be closed by the process which opened it or by its children. 
	<div>Syntax : <tt>int Close(fileDescriptor) </tt></div> 
	<div>Syscall no : 4</div>
	<ul>
		<li> The <tt>fileDescriptor</tt> is used first to access the local file table entry of the file. An appropriate error code is returned if the <tt>fileDescriptor</tt> is out of the range specified.
		
		<li> The global file table entry indexed by this local file table entry is removed.
		
		<li> The local file table entry of the process is then removed.
		
		<li> The return value of this system call is 0 in case of success and the appropriate error code in case of failure.
	</ul>
</ol>

<h3>INT 3</h3>
<p>
The file system calls <i>Read</i> and <i>Seek</i> invoke INT 3. INT 3 handles these system calls as follows.
</p>
<ol>
	<li> <b>Seek :</b> This system call is used to change the current value of the seek position in the global file table entry of a file. 
	<div>Syntax : <tt>int Seek(fileDescriptor, lseek)</tt><div>
	<div>Syscall no : 5</div>
	<ul>
		<li> The <tt>fileDescriptor</tt> is used first to access the local file table entry of the file. An appropriate error code is returned if the <tt>fileDescriptor</tt> is out of the range specified.
		<li> This local file table entry is then used to access the global file table entry of the file.
		<li> Then the FAT index field in the global file table entry is used to access the FAT entry of the file.
		<li> The <em>file size</em> got from this FAT entry is checked to be greater than <tt>lseek</tt>. Otherwise an appropriate error code is returned.
		<li> The <em>lseek</em> field in the GFT entry is then changed to the new value specified in the argument (<tt>lseek</tt>).
		<li> The return value of this system call is 0 in case of success and the appropriate error code in case of failure.
	</ul>
	
	<li> <b>Read :</b> This system call is used to read data from an open file.
	<div>Syntax : <tt>int Read(fileDescriptor, mem_loc, numWords)</tt></div>
	<div>Syscall no : 6</div>
	<ul>
		<li> First of all, the basic block of the file specified by the <tt>fileDescriptor</tt> is loaded in the scratchpad. This is done in the following way:
		<ul>
			<li> The <tt>fileDescriptor</tt> is used first to access the local file table entry of the file. An appropriate error is returned if the <tt>fileDescriptor</tt> is out of the range specified.
			<li> This local file table entry is then used to access the global file table entry of the file. 
			<li> Then the <em>FAT index</em> field in the global file table entry is used to access the FAT entry of the file.
			<li> The basic block address present in the FAT entry is then used to load the basic block (containing block list and file header info) into the scratchpad.
		</ul>	
		<li> The <em>lseek</em> position present in the GFT entry and <tt>numWords</tt> are used to index the block list in the basic block to find the address of the block(s) to be read.
		<li> Each time the block to be read is loaded into the scratchpad before reading its contents.
		<li> The contents read are then copied into the buffer that is specified as an argument to the system call (<tt>mem_loc</tt>). If the <tt>mem_loc</tt> is out of the address space of the process, an appropriate error code is returned.
		<li> The return value of this system call is the number of words successfully read. In case of an error, an appropriate error code is returned.
	</ul>
</ol>


<div id="imageCaption">
<img src="./images/access_method.png" alt="Accessing FAT entry"><br/>
Diagram showing the method of accessing FAT entry</div>

<h3>INT 4</h3>
<p>
The file system call <i>Write</i> invoke INT 4. INT 4 handles these system calls as follows.
</p>
<b>Write :</b> This system call is used to write data into an open file. 
<div>Syntax : <tt>int Write(fileDescriptor, mem_loc, numWords)</tt></div>
<div>Syscall no : 7</div>
<ul>
	<li> First of all, the basic block of the file specified by the <tt>fileDescriptor</tt> is loaded into the scratchpad. This is done in the following way:
	<ul>
		<li> The <tt>fileDescriptor</tt> is used first to access the local file table entry of the file. An appropriate error is returned if the <tt>fileDescriptor</tt> is out of the range specified.
		<li> This local file table entry is then used to access the global file table entry of the file.
		<li> Then the FAT index field in the global file table entry is used to access the FAT entry of the file.
		<li> The basic block address present in the FAT entry is then used load the basic block (containing block list and file header info) into the scratchpad.
	</ul>	
	
	<li> The lseek position present in the GFT entry and <tt>numWords</tt> are used to index the block list in the basic block to find the block numbers of the block(s) to be written into.
	
	<li> Each time the block to be written into is loaded into the scratchpad before performing the write operation.
	
	<li> After loading the specified block, the content to be written is copied from the user memory location (<tt>mem_loc</tt>) into this block. If <tt>mem_loc</tt> is out of the address space of the process, an appropriate error code is returned.
	
	<li> If the write operation exhausts all the currently allocated blocks, new blocks are allocated as required. This is done in the following way.
	<ul>
		<li> The memory copy of the disk free list is used to get the block number of a free block.
		<li> A new basic block entry is created using this free block number and added to the block list of the basic block. Successive write operations are then performed the usual way.
	</ul>
	
	<li> Once all the write operations are over for that block, it is stored back into the disk.
	
	<li> The updated copies of FAT and disk free list in the memory are committed to the disk.
	
	<li> The return value of this system call is the number of words successfully written. In case of an error, an appropriate error code is returned.
</ul>

<div id="nav3"><div id="prev"><a href="./Halt.html">Prev</a></div>
<div id="next"><a href="./Multiprogramming.html">Next</a></div>
</div>
</div>
</body>
</html>